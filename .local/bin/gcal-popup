#!/usr/bin/env python3
"""GTK4 floating calendar popup with event list for waybar."""

import json
import os
import signal
import subprocess
from datetime import datetime, date
from pathlib import Path

import gi

gi.require_version("Gtk", "4.0")
gi.require_version("Gdk", "4.0")
gi.require_version("Gtk4LayerShell", "1.0")
from gi.repository import Gtk, Gdk, GLib, Pango, Gtk4LayerShell as LayerShell

CACHE_DIR = Path(os.environ.get("XDG_CACHE_HOME", Path.home() / ".cache")) / "gcal"
EVENTS_FILE = CACHE_DIR / "events.json"


def load_events():
    """Load events from cache."""
    if not EVENTS_FILE.exists():
        return []
    try:
        data = json.loads(EVENTS_FILE.read_text())
        return data.get("events", [])
    except (json.JSONDecodeError, KeyError):
        return []


def events_for_date(events, d):
    """Filter events for a specific date."""
    date_str = d.strftime("%Y-%m-%d")
    result = []
    for e in events:
        start = e["start"]
        if start.startswith(date_str):
            result.append(e)
        elif e["all_day"]:
            # Multi-day all-day events
            end = e["end"]
            if start[:10] <= date_str < end[:10]:
                result.append(e)
    return result


class CalendarPopup(Gtk.Application):
    def __init__(self):
        super().__init__(application_id="com.gcal.popup")
        self.events = load_events()
        self.selected_date = date.today()

    def do_activate(self):
        # Kill any existing instance
        win = Gtk.ApplicationWindow(application=self)
        win.set_default_size(340, 460)
        win.set_resizable(False)

        # Layer shell: anchor top-right, near the clock
        LayerShell.init_for_window(win)
        LayerShell.set_layer(win, LayerShell.Layer.TOP)
        LayerShell.set_anchor(win, LayerShell.Edge.TOP, True)
        LayerShell.set_anchor(win, LayerShell.Edge.RIGHT, True)
        LayerShell.set_margin(win, LayerShell.Edge.TOP, 35)
        LayerShell.set_margin(win, LayerShell.Edge.RIGHT, 10)
        LayerShell.set_keyboard_mode(win, LayerShell.KeyboardMode.ON_DEMAND)

        # Close on Escape
        key_ctrl = Gtk.EventControllerKey()
        key_ctrl.connect("key-pressed", self._on_key)
        win.add_controller(key_ctrl)

        # Close on focus loss (delayed so the window has time to grab focus)
        def _arm_focus_close():
            focus_ctrl = Gtk.EventControllerFocus()
            focus_ctrl.connect("leave", lambda _: win.close())
            win.add_controller(focus_ctrl)
            return GLib.SOURCE_REMOVE

        GLib.timeout_add(500, _arm_focus_close)

        # Main layout
        vbox = Gtk.Box(orientation=Gtk.Orientation.VERTICAL, spacing=0)
        vbox.add_css_class("main-box")
        win.set_child(vbox)

        # Calendar
        self.calendar = Gtk.Calendar()
        self.calendar.connect("day-selected", self._on_day_selected)
        vbox.append(self.calendar)

        # Mark days with events
        self._mark_event_days()

        # Separator
        vbox.append(Gtk.Separator())

        # Event list (scrollable)
        scroll = Gtk.ScrolledWindow()
        scroll.set_vexpand(True)
        scroll.set_policy(Gtk.PolicyType.NEVER, Gtk.PolicyType.AUTOMATIC)
        vbox.append(scroll)

        self.event_list = Gtk.Box(orientation=Gtk.Orientation.VERTICAL, spacing=2)
        self.event_list.set_margin_top(6)
        self.event_list.set_margin_bottom(6)
        self.event_list.set_margin_start(8)
        self.event_list.set_margin_end(8)
        scroll.set_child(self.event_list)

        self._populate_events()

        # CSS
        css = Gtk.CssProvider()
        css.load_from_string(
            """
            .main-box {
                background-color: rgba(30, 30, 40, 0.95);
            }
            calendar {
                background-color: transparent;
                color: #e0e0e0;
                font-size: 11px;
            }
            .event-row {
                padding: 4px 6px;
                border-radius: 4px;
                background-color: rgba(60, 60, 80, 0.5);
            }
            .event-row:hover {
                background-color: rgba(80, 80, 110, 0.6);
            }
            .event-time {
                color: #89cff0;
                font-size: 10px;
                font-family: Iosevka;
            }
            .event-title {
                color: #e0e0e0;
                font-size: 11px;
            }
            .event-calendar {
                color: #808080;
                font-size: 9px;
            }
            .meeting-icon {
                color: #00ff7f;
                font-size: 10px;
            }
            .all-day-tag {
                color: #ffa500;
                font-size: 9px;
            }
            .no-events {
                color: #606060;
                font-size: 11px;
            }
            separator {
                background-color: rgba(100, 100, 120, 0.3);
                min-height: 1px;
            }
            """
        )
        Gtk.StyleContext.add_provider_for_display(
            Gdk.Display.get_default(),
            css,
            Gtk.STYLE_PROVIDER_PRIORITY_APPLICATION,
        )

        win.present()

    def _on_key(self, ctrl, keyval, keycode, state):
        if keyval == Gdk.KEY_Escape:
            self.get_active_window().close()
            return True
        return False

    def _mark_event_days(self):
        """Mark days that have events in the calendar widget."""
        self.calendar.clear_marks()
        cal_date = self.calendar.get_date()
        year = cal_date.get_year()
        month = cal_date.get_month()

        for e in self.events:
            start = e["start"][:10]
            try:
                d = datetime.strptime(start, "%Y-%m-%d")
                if d.year == year and d.month == month:
                    self.calendar.mark_day(d.day)
            except ValueError:
                continue

    def _on_day_selected(self, calendar):
        gdate = calendar.get_date()
        self.selected_date = date(gdate.get_year(), gdate.get_month(), gdate.get_day_of_month())
        self._mark_event_days()
        self._populate_events()

    def _populate_events(self):
        # Clear existing
        while True:
            child = self.event_list.get_first_child()
            if child is None:
                break
            self.event_list.remove(child)

        day_events = events_for_date(self.events, self.selected_date)

        if not day_events:
            label = Gtk.Label(label="No events")
            label.add_css_class("no-events")
            label.set_margin_top(20)
            self.event_list.append(label)
            return

        for e in day_events:
            row = Gtk.Box(orientation=Gtk.Orientation.HORIZONTAL, spacing=6)
            row.add_css_class("event-row")

            # Time or "All day"
            if e["all_day"]:
                time_label = Gtk.Label(label="All day")
                time_label.add_css_class("all-day-tag")
            else:
                t = datetime.fromisoformat(e["start"]).strftime("%H:%M")
                time_label = Gtk.Label(label=t)
                time_label.add_css_class("event-time")
            time_label.set_size_request(45, -1)
            time_label.set_xalign(0)
            row.append(time_label)

            # Meeting icon
            if e.get("meeting_url"):
                icon = Gtk.Label(label="")
                icon.add_css_class("meeting-icon")
                row.append(icon)

            # Title + calendar name
            info_box = Gtk.Box(orientation=Gtk.Orientation.VERTICAL, spacing=0)
            info_box.set_hexpand(True)

            title = Gtk.Label(label=e["summary"])
            title.add_css_class("event-title")
            title.set_xalign(0)
            title.set_ellipsize(Pango.EllipsizeMode.END)
            title.set_max_width_chars(30)
            info_box.append(title)

            cal_label = Gtk.Label(label=e.get("calendar", ""))
            cal_label.add_css_class("event-calendar")
            cal_label.set_xalign(0)
            info_box.append(cal_label)

            row.append(info_box)

            # Make clickable if has meeting URL or html_link
            link = e.get("meeting_url") or e.get("html_link")
            if link:
                gesture = Gtk.GestureClick()
                gesture.connect("released", self._on_event_click, link)
                row.add_controller(gesture)
                row.set_cursor(Gdk.Cursor.new_from_name("pointer"))

            self.event_list.append(row)

    def _on_event_click(self, gesture, n_press, x, y, url):
        subprocess.Popen(["xdg-open", url], stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)


def main():
    # If already running, quit the existing instance (toggle behavior)
    app = CalendarPopup()
    signal.signal(signal.SIGINT, signal.SIG_DFL)
    app.run(None)


if __name__ == "__main__":
    main()

#!/bin/bash
# Quick command runner with readline TAB completion

HISTORY_FILE=~/.run-command-history
touch "$HISTORY_FILE"

# Source bash-completion for full TAB completion
if [[ -f /usr/share/bash-completion/bash_completion ]]; then
    . /usr/share/bash-completion/bash_completion
fi

# Load our history into readline
HISTFILE="$HISTORY_FILE"
history -r "$HISTORY_FILE"

# State for checkbox
SHOW_OUTPUT=0

draw_header() {
    local checkbox
    if ((SHOW_OUTPUT)); then
        checkbox="[x]"
    else
        checkbox="[ ]"
    fi
    printf '\e[1;1H'  # go to line 1
    printf '\e[K'     # clear line
    printf "  %s Show output (Shift-Tab)\n" "$checkbox"
    printf '\e[K'
    printf "  Tab=complete | Up/Down=history | Ctrl-C=exit\n"
    printf '\e[K\n'
}

toggle_output() {
    ((SHOW_OUTPUT ^= 1))
    printf '\e7'           # save cursor
    draw_header
    printf '\e8'           # restore cursor
}

# Trap Ctrl-C to exit cleanly
trap 'printf "\e[?25h\e[J"; exit 0' INT

# Clear screen and hide cursor during setup
printf '\e[2J\e[H'

# Draw initial header
draw_header

# Enable readline and bind SHIFT-TAB to toggle function
set -o emacs
bind -x '"\e[Z": toggle_output'

# Position cursor for prompt
printf "  Run: "

# Use readline for input with TAB completion and history
read -e CMD

# Unbind our custom key
bind -r '\e[Z' 2>/dev/null

# Clear screen and show cursor
printf '\e[?25h\e[2J\e[H'

[[ -z "$CMD" ]] && exit 0

# Save to history (avoid duplicates, keep recent at bottom)
grep -v -Fx "$CMD" "$HISTORY_FILE" > "$HISTORY_FILE.tmp" 2>/dev/null
mv "$HISTORY_FILE.tmp" "$HISTORY_FILE"
echo "$CMD" >> "$HISTORY_FILE"

# Keep history to 500 lines
tail -500 "$HISTORY_FILE" > "$HISTORY_FILE.tmp" && mv "$HISTORY_FILE.tmp" "$HISTORY_FILE"

if [[ "$SHOW_OUTPUT" == "1" ]]; then
    OUTPUT_FILE=$(mktemp /tmp/run-cmd-XXXXXX.log)
    echo "$ $CMD" > "$OUTPUT_FILE"
    echo "---" >> "$OUTPUT_FILE"
    # Run command in background, appending output
    hyprctl dispatch exec "bash -c '$CMD >> \"$OUTPUT_FILE\" 2>&1; echo \"---\" >> \"$OUTPUT_FILE\"; echo \"Exit code: \$?\" >> \"$OUTPUT_FILE\"'"
    # Open in Emacs with auto-revert (detached from foot)
    hyprctl dispatch exec "emacsclient -c -a emacs -q --eval '(progn (find-file \"$OUTPUT_FILE\") (auto-revert-mode 1) (delete-other-windows))'"
else
    # Run via hyprctl and flash exit code (clears after 3 seconds)
    WRAPPER=$(mktemp /tmp/run-cmd-wrapper-XXXXXX.sh)
    cat > "$WRAPPER" << INNEREOF
#!/bin/bash
$CMD > /dev/null 2>&1
ec=\$?
log_message "\$([ \$ec -eq 0 ] && echo '✓' || echo '✗') \$ec"
sleep 3
log_message ""
rm "$WRAPPER"
INNEREOF
    chmod +x "$WRAPPER"
    hyprctl dispatch exec "$WRAPPER"
fi
